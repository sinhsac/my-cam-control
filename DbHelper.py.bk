import mysql.connector
from mysql.connector import Error
from typing import List, Dict, Any, Optional, Tuple, Union
import logging


class DbHelper:
    """
    Common MySQL Database Helper Class
    Provides easy-to-use methods for SELECT, INSERT, UPDATE, DELETE operations
    Including batch operations for better performance
    """

    def __init__(self, host="192.168.1.22", user="root", password="root", database="testuse_config"):
        """
        Initialize database connection parameters
        """
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.connection = None
        self.cursor = None

        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    def get_connection(self) -> mysql.connector.MySQLConnection:
        """
        Create and return database connection
        """
        try:
            if self.connection is None or not self.connection.is_connected():
                self.connection = mysql.connector.connect(
                    host=self.host,
                    user=self.user,
                    password=self.password,
                    database=self.database,
                    autocommit=False  # Disable autocommit for transaction control
                )
                self.logger.info("Database connection established")
            return self.connection
        except Error as e:
            self.logger.error(f"Error connecting to database: {e}")
            raise

    def close_connection(self):
        """
        Close database connection and cursor
        """
        try:
            if self.cursor:
                self.cursor.close()
                self.cursor = None
            if self.connection and self.connection.is_connected():
                self.connection.close()
                self.connection = None
                self.logger.info("Database connection closed")
        except Error as e:
            self.logger.error(f"Error closing connection: {e}")

    def __enter__(self):
        """Context manager entry"""
        self.get_connection()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close_connection()

    def execute_query(self, query: str, params: Optional[Tuple] = None) -> List[Tuple]:
        """
        Execute SELECT query and return results

        Args:
            query: SQL SELECT query
            params: Query parameters (optional)

        Returns:
            List of tuples containing query results
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            if params:
                self.cursor.execute(query, params)
            else:
                self.cursor.execute(query)

            results = self.cursor.fetchall()
            self.logger.info(f"Query executed successfully. Returned {len(results)} rows")
            return results

        except Error as e:
            self.logger.error(f"Error executing query: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def execute_query_dict(self, query: str, params: Optional[Tuple] = None) -> List[Dict]:
        """
        Execute SELECT query and return results as list of dictionaries

        Args:
            query: SQL SELECT query
            params: Query parameters (optional)

        Returns:
            List of dictionaries containing query results
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor(dictionary=True)

            if params:
                self.cursor.execute(query, params)
            else:
                self.cursor.execute(query)

            results = self.cursor.fetchall()
            self.logger.debug(f"Query executed successfully. Returned {len(results)} rows")
            return results

        except Error as e:
            self.logger.error(f"Error executing query: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def select_all(self, table: str, conditions: Optional[str] = None, params: Optional[Tuple] = None) -> List[Dict]:
        """
        Select all records from table with optional conditions

        Args:
            table: Table name
            conditions: WHERE clause conditions (without WHERE keyword)
            params: Parameters for conditions

        Returns:
            List of dictionaries containing results
        """
        query = f"SELECT * FROM {table}"
        if conditions:
            query += f" WHERE {conditions}"

        return self.execute_query_dict(query, params)

    def select_by_id(self, table: str, id_value: Any, id_column: str = "id") -> Optional[Dict]:
        """
        Select single record by ID

        Args:
            table: Table name
            id_value: ID value to search for
            id_column: ID column name (default: 'id')

        Returns:
            Dictionary containing record or None if not found
        """
        query = f"SELECT * FROM {table} WHERE {id_column} = %s"
        results = self.execute_query_dict(query, (id_value,))
        return results[0] if results else None

    def insert_one(self, table: str, data: Dict[str, Any]) -> int:
        """
        Insert single record into table

        Args:
            table: Table name
            data: Dictionary containing column names and values

        Returns:
            Last inserted ID
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            columns = ", ".join(data.keys())
            placeholders = ", ".join(["%s"] * len(data))
            query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"

            self.cursor.execute(query, tuple(data.values()))
            conn.commit()

            last_id = self.cursor.lastrowid
            self.logger.info(f"Record inserted successfully. ID: {last_id}")
            return last_id

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error inserting record: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def insert_batch(self, table: str, data_list: List[Dict[str, Any]]) -> int:
        """
        Insert multiple records in batch

        Args:
            table: Table name
            data_list: List of dictionaries containing column names and values

        Returns:
            Number of affected rows
        """
        if not data_list:
            return 0

        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            # Get columns from first record
            columns = ", ".join(data_list[0].keys())
            placeholders = ", ".join(["%s"] * len(data_list[0]))
            query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"

            # Prepare data for executemany
            values_list = [tuple(record.values()) for record in data_list]

            self.cursor.executemany(query, values_list)
            conn.commit()

            affected_rows = self.cursor.rowcount
            self.logger.info(f"Batch insert completed. {affected_rows} records inserted")
            return affected_rows

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error in batch insert: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def update_by_id(self, table: str, id_value: Any, data: Dict[str, Any], id_column: str = "id") -> int:
        """
        Update record by ID

        Args:
            table: Table name
            id_value: ID value to update
            data: Dictionary containing column names and new values
            id_column: ID column name (default: 'id')

        Returns:
            Number of affected rows
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            set_clause = ", ".join([f"{key} = %s" for key in data.keys()])
            query = f"UPDATE {table} SET {set_clause} WHERE {id_column} = %s"

            params = tuple(data.values()) + (id_value,)
            self.cursor.execute(query, params)
            conn.commit()

            affected_rows = self.cursor.rowcount
            self.logger.info(f"Update completed. {affected_rows} rows affected")
            return affected_rows

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error updating record: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def update_with_conditions(self, table: str, data: Dict[str, Any], conditions: str,
                               params: Optional[Tuple] = None) -> int:
        """
        Update records with custom conditions

        Args:
            table: Table name
            data: Dictionary containing column names and new values
            conditions: WHERE clause conditions (without WHERE keyword)
            params: Parameters for conditions

        Returns:
            Number of affected rows
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            set_clause = ", ".join([f"{key} = %s" for key in data.keys()])
            query = f"UPDATE {table} SET {set_clause} WHERE {conditions}"

            update_params = tuple(data.values())
            if params:
                update_params += params

            self.cursor.execute(query, update_params)
            conn.commit()

            affected_rows = self.cursor.rowcount
            self.logger.info(f"Update completed. {affected_rows} rows affected")
            return affected_rows

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error updating records: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def update_batch(self, table: str, data_list: List[Dict[str, Any]], id_column: str = "id") -> int:
        """
        Update multiple records in batch
        Each dictionary must contain the ID column

        Args:
            table: Table name
            data_list: List of dictionaries containing column names, values, and ID
            id_column: ID column name (default: 'id')

        Returns:
            Number of affected rows
        """
        if not data_list:
            return 0

        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            total_affected = 0

            for data in data_list:
                if id_column not in data:
                    raise ValueError(f"ID column '{id_column}' not found in data")

                id_value = data.pop(id_column)  # Remove ID from data to avoid updating it

                set_clause = ", ".join([f"{key} = %s" for key in data.keys()])
                query = f"UPDATE {table} SET {set_clause} WHERE {id_column} = %s"

                params = tuple(data.values()) + (id_value,)
                self.cursor.execute(query, params)
                total_affected += self.cursor.rowcount

                # Add ID back to data (in case it's needed elsewhere)
                data[id_column] = id_value

            conn.commit()
            self.logger.info(f"Batch update completed. {total_affected} rows affected")
            return total_affected

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error in batch update: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def delete_by_id(self, table: str, id_value: Any, id_column: str = "id") -> int:
        """
        Delete record by ID

        Args:
            table: Table name
            id_value: ID value to delete
            id_column: ID column name (default: 'id')

        Returns:
            Number of affected rows
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            query = f"DELETE FROM {table} WHERE {id_column} = %s"
            self.cursor.execute(query, (id_value,))
            conn.commit()

            affected_rows = self.cursor.rowcount
            self.logger.info(f"Delete completed. {affected_rows} rows affected")
            return affected_rows

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error deleting record: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def delete_with_conditions(self, table: str, conditions: str, params: Optional[Tuple] = None) -> int:
        """
        Delete records with custom conditions

        Args:
            table: Table name
            conditions: WHERE clause conditions (without WHERE keyword)
            params: Parameters for conditions

        Returns:
            Number of affected rows
        """
        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            query = f"DELETE FROM {table} WHERE {conditions}"

            if params:
                self.cursor.execute(query, params)
            else:
                self.cursor.execute(query)

            conn.commit()

            affected_rows = self.cursor.rowcount
            self.logger.info(f"Delete completed. {affected_rows} rows affected")
            return affected_rows

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error deleting records: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None

    def count_records(self, table: str, conditions: Optional[str] = None, params: Optional[Tuple] = None) -> int:
        """
        Count records in table with optional conditions

        Args:
            table: Table name
            conditions: WHERE clause conditions (without WHERE keyword)
            params: Parameters for conditions

        Returns:
            Number of records
        """
        query = f"SELECT COUNT(*) FROM {table}"
        if conditions:
            query += f" WHERE {conditions}"

        results = self.execute_query(query, params)
        return results[0][0] if results else 0


    def insert_or_update_batch(self, table: str, data_list: List[Dict[str, Any]],
                               unique_columns: Union[str, List[str]],
                               update_columns: Optional[List[str]] = None) -> Dict[str, int]:
        """
        Insert batch records, if unique columns exist then update specified columns
        Uses MySQL's INSERT ... ON DUPLICATE KEY UPDATE syntax

        Args:
            table: Table name
            data_list: List of dictionaries containing column names and values
            unique_columns: Column name(s) to check for duplicates (can be string or list)
                           These columns must have UNIQUE constraint or be PRIMARY KEY
            update_columns: List of column names to update when duplicate found
                           If None, all columns except unique_columns will be updated

        Returns:
            Dictionary with 'inserted' and 'updated' counts

        Example:
            # Insert or update by single unique column
            db.insert_or_update_batch(
                "xcam_cameras",
                [{"ip": "192.168.1.100", "name": "Camera1", "status": "active"}],
                unique_columns="ip"
            )

            # Insert or update by multiple unique columns
            db.insert_or_update_batch(
                "users",
                [{"email": "user@test.com", "phone": "123456", "name": "John", "age": 30}],
                unique_columns=["email", "phone"],
                update_columns=["name", "age"]  # Only update these columns
            )
        """
        if not data_list:
            return {"inserted": 0, "updated": 0}

        try:
            conn = self.get_connection()
            self.cursor = conn.cursor()

            # Normalize unique_columns to list
            if isinstance(unique_columns, str):
                unique_columns = [unique_columns]

            # Get all columns from first record
            all_columns = list(data_list[0].keys())

            # Determine columns to update
            if update_columns is None:
                # Update all columns except unique columns
                update_columns = [col for col in all_columns if col not in unique_columns]

            # Validate that unique columns exist in data
            for col in unique_columns:
                if col not in all_columns:
                    raise ValueError(f"Unique column '{col}' not found in data")

            # Validate that update columns exist in data
            for col in update_columns:
                if col not in all_columns:
                    raise ValueError(f"Update column '{col}' not found in data")

            # Build INSERT part
            columns = ", ".join(all_columns)
            placeholders = ", ".join(["%s"] * len(all_columns))

            # Build ON DUPLICATE KEY UPDATE part
            update_clause = ", ".join([f"{col} = VALUES({col})" for col in update_columns])

            query = f"""
            INSERT INTO {table} ({columns}) 
            VALUES ({placeholders})
            ON DUPLICATE KEY UPDATE {update_clause}
            """

            # Prepare data for executemany
            values_list = [tuple(record.values()) for record in data_list]

            # Execute batch insert/update
            self.cursor.executemany(query, values_list)
            conn.commit()

            # Calculate inserted vs updated records
            total_affected = self.cursor.rowcount

            # In MySQL, for INSERT ... ON DUPLICATE KEY UPDATE:
            # - If new record inserted: affected_rows = 1
            # - If existing record updated: affected_rows = 2
            # - If existing record not changed: affected_rows = 0

            # Note: MySQL doesn't provide exact counts, this is an approximation
            # For exact counts, you would need to check before insertion
            estimated_updated = max(0, total_affected - len(data_list))
            estimated_inserted = len(data_list) - estimated_updated

            result = {
                "inserted": estimated_inserted,
                "updated": estimated_updated,
                "total_affected": total_affected
            }

            self.logger.info(
                f"Batch upsert completed. Estimated - Inserted: {estimated_inserted}, Updated: {estimated_updated}")
            return result

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error in batch upsert: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None


    def insert_or_update_batch_precise(self, table: str, data_list: List[Dict[str, Any]],
                                       unique_columns: Union[str, List[str]],
                                       update_columns: Optional[List[str]] = None) -> Dict[str, int]:

        if not data_list:
            return {"inserted": 0, "updated": 0}
        conn = self.get_connection()
        try:
            self.cursor = conn.cursor()

            # Normalize unique_columns to list
            if isinstance(unique_columns, str):
                unique_columns = [unique_columns]

            # Get all columns from first record
            all_columns = list(data_list[0].keys())

            # Determine columns to update
            if update_columns is None:
                update_columns = [col for col in all_columns if col not in unique_columns]

            inserted_count = 0
            updated_count = 0

            for data in data_list:
                # Build condition to check if record exists
                conditions = " AND ".join([f"{col} = %s" for col in unique_columns])
                condition_values = tuple(data[col] for col in unique_columns)

                # Check if record exists
                check_query = f"SELECT 1 FROM {table} WHERE {conditions} LIMIT 1"
                self.cursor.execute(check_query, condition_values)
                exists = self.cursor.fetchone() is not None

                if exists:
                    # Update existing record
                    if update_columns:
                        set_clause = ", ".join([f"{col} = %s" for col in update_columns])
                        update_query = f"UPDATE {table} SET {set_clause} WHERE {conditions}"

                        update_values = tuple(data[col] for col in update_columns) + condition_values
                        self.cursor.execute(update_query, update_values)

                        if self.cursor.rowcount > 0:
                            updated_count += 1
                else:
                    # Insert new record
                    columns = ", ".join(all_columns)
                    placeholders = ", ".join(["%s"] * len(all_columns))
                    insert_query = f"INSERT INTO {table} ({columns}) VALUES ({placeholders})"

                    self.cursor.execute(insert_query, tuple(data.values()))
                    inserted_count += 1

            conn.commit()

            result = {
                "inserted": inserted_count,
                "updated": updated_count,
                "total_affected": inserted_count + updated_count
            }

            self.logger.info(f"Precise batch upsert completed. Inserted: {inserted_count}, Updated: {updated_count}")
            return result

        except Error as e:
            conn.rollback()
            self.logger.error(f"Error in precise batch upsert: {e}")
            raise
        finally:
            if self.cursor:
                self.cursor.close()
                self.cursor = None


    def select_first_order_by(self, table: str, col_name: str, sort_type: str = 'ASC',
                              conditions: Optional[str] = None, params: Optional[Tuple] = None) -> Optional[Dict]:
        """
        Select first record ordered by specified column

        Args:
            table: Table name
            col_name: Column name to order by
            sort_type: Sort direction ('ASC' or 'DESC'), default 'ASC'
            conditions: WHERE clause conditions (optional)
            params: Parameters for conditions (optional)

        Returns:
            Dictionary containing first record or None if no records found

        Example:
            # Get oldest camera
            oldest = db.select_first_order_by("xcam_cameras", "created_at", "ASC")

            # Get latest active camera
            latest_active = db.select_first_order_by(
                "xcam_cameras",
                "created_at",
                "DESC",
                conditions="status = %s",
                params=("active",)
            )
        """
        # Validate sort_type to prevent SQL injection
        sort_type = sort_type.upper()
        if sort_type not in ['ASC', 'DESC']:
            raise ValueError("sort_type must be 'ASC' or 'DESC'")

        # Build query
        query = f"SELECT * FROM {table}"

        if conditions:
            query += f" WHERE {conditions}"

        query += f" ORDER BY {col_name} {sort_type} LIMIT 1"

        results = self.execute_query_dict(query, params)
        return results[0] if results else None


    def select_first_multiple_order_by(self, table: str, order_columns: List[Tuple[str, str]],
                                       conditions: Optional[str] = None, params: Optional[Tuple] = None) -> Optional[Dict]:
        """
        Select first record ordered by multiple columns

        Args:
            table: Table name
            order_columns: List of tuples (column_name, sort_direction)
            conditions: WHERE clause conditions (optional)
            params: Parameters for conditions (optional)

        Returns:
            Dictionary containing first record or None if no records found

        Example:
            # Order by status DESC, then by created_at ASC
            result = db.select_first_multiple_order_by(
                "xcam_cameras",
                [("status", "DESC"), ("created_at", "ASC")]
            )
        """
        if not order_columns:
            raise ValueError("order_columns cannot be empty")

        # Validate and build ORDER BY clause
        order_parts = []
        for col_name, sort_type in order_columns:
            sort_type = sort_type.upper()
            if sort_type not in ['ASC', 'DESC']:
                raise ValueError(f"sort_type must be 'ASC' or 'DESC', got '{sort_type}' for column '{col_name}'")
            order_parts.append(f"{col_name} {sort_type}")

        order_clause = ", ".join(order_parts)

        # Build query
        query = f"SELECT * FROM {table}"

        if conditions:
            query += f" WHERE {conditions}"

        query += f" ORDER BY {order_clause} LIMIT 1"

        results = self.execute_query_dict(query, params)
        return results[0] if results else None


    def select_top_n_order_by(self, table: str, col_name: str, sort_type: str = 'ASC',
                              limit: int = 10, conditions: Optional[str] = None,
                              params: Optional[Tuple] = None) -> List[Dict]:
        """
        Select top N records ordered by specified column

        Args:
            table: Table name
            col_name: Column name to order by
            sort_type: Sort direction ('ASC' or 'DESC'), default 'ASC'
            limit: Number of records to return, default 10
            conditions: WHERE clause conditions (optional)
            params: Parameters for conditions (optional)

        Returns:
            List of dictionaries containing records

        Example:
            # Get top 5 most recent cameras
            recent_cameras = db.select_top_n_order_by(
                "xcam_cameras",
                "created_at",
                "DESC",
                limit=5
            )
        """
        # Validate parameters
        sort_type = sort_type.upper()
        if sort_type not in ['ASC', 'DESC']:
            raise ValueError("sort_type must be 'ASC' or 'DESC'")

        if limit <= 0:
            raise ValueError("limit must be greater than 0")

        # Build query
        query = f"SELECT * FROM {table}"

        if conditions:
            query += f" WHERE {conditions}"

        query += f" ORDER BY {col_name} {sort_type} LIMIT {limit}"

        return self.execute_query_dict(query, params)


    # Convenience methods for common use cases
    def select_oldest(self, table: str, date_column: str = 'created_at',
                      conditions: Optional[str] = None, params: Optional[Tuple] = None) -> Optional[Dict]:
        """Get oldest record by date column"""
        return self.select_first_order_by(table, date_column, 'ASC', conditions, params)


    def select_newest(self, table: str, date_column: str = 'created_at',
                      conditions: Optional[str] = None, params: Optional[Tuple] = None) -> Optional[Dict]:
        """Get newest record by date column"""
        return self.select_first_order_by(table, date_column, 'DESC', conditions, params)


    def select_min_value(self, table: str, col_name: str,
                         conditions: Optional[str] = None, params: Optional[Tuple] = None) -> Optional[Dict]:
        """Get record with minimum value in specified column"""
        return self.select_first_order_by(table, col_name, 'ASC', conditions, params)


    def select_max_value(self, table: str, col_name: str,
                         conditions: Optional[str] = None, params: Optional[Tuple] = None) -> Optional[Dict]:
        """Get record with maximum value in specified column"""
        return self.select_first_order_by(table, col_name, 'DESC', conditions, params)


    # Example usage
    def example_select_first_usage():
        """Example usage of the select_first functions"""
        db = DbHelper()

        try:
            # Example 1: Get oldest camera
            oldest_camera = db.select_first_order_by("xcam_cameras", "created_at", "ASC")
            print(f"Oldest camera: {oldest_camera}")

            # Example 2: Get latest active camera
            latest_active = db.select_first_order_by(
                "xcam_cameras",
                "updated_at",
                "DESC",
                conditions="status = %s",
                params=("active",)
            )
            print(f"Latest active camera: {latest_active}")

            # Example 3: Get camera with highest ID in specific location
            highest_id = db.select_first_order_by(
                "xcam_cameras",
                "id",
                "DESC",
                conditions="location = %s",
                params=("office",)
            )
            print(f"Camera with highest ID in office: {highest_id}")

            # Example 4: Multiple column ordering
            priority_camera = db.select_first_multiple_order_by(
                "xcam_cameras",
                [("priority", "DESC"), ("created_at", "ASC")],
                conditions="status = %s",
                params=("active",)
            )
            print(f"Priority active camera: {priority_camera}")

            # Example 5: Top 3 newest cameras
            newest_cameras = db.select_top_n_order_by(
                "xcam_cameras",
                "created_at",
                "DESC",
                limit=3
            )
            print(f"Top 3 newest cameras: {newest_cameras}")

            # Example 6: Using convenience methods
            oldest = db.select_oldest("xcam_cameras")
            newest = db.select_newest("xcam_cameras")
            min_priority = db.select_min_value("xcam_cameras", "priority")

            print(f"Oldest: {oldest}")
            print(f"Newest: {newest}")
            print(f"Min priority: {min_priority}")

        except Exception as e:
            print(f"Error: {e}")
        finally:
            db.close_connection()

